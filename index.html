<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infinity‑OS • System Orchestrator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* ===== Infinity-OS System Skin (color logic mindful) ===== */
:root {
  --bg-0: #0b0f17;
  --bg-1: #121826;
  --bg-2: #171f2e;
  --ink-0: #e6f1ff;
  --ink-1: #bfe3ff;
  --accent-1: #00ff9d;    /* life / green */
  --accent-2: #6aa9ff;    /* sky / blue */
  --accent-3: #ff6f61;    /* impulse / coral */
  --accent-4: #ffd166;    /* signal / amber */
  --accent-5: #c792ea;    /* idea / violet */
  --fail: #ff3b2e;
  --ok:   #00ff9d;
  --mute: #8aa1b8;
  --panel: rgba(255,255,255,0.06);
  --panel-strong: rgba(255,255,255,0.12);
  --shadow: 0 10px 24px rgba(0,0,0,0.35);
}

* { box-sizing: border-box; }
html, body {
  margin:0; padding:0; background: var(--bg-0); color: var(--ink-0);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
}

header {
  padding: 22px 24px;
  background: linear-gradient(135deg, var(--bg-1), var(--bg-2));
  border-bottom: 1px solid rgba(255,255,255,0.08);
  box-shadow: var(--shadow);
}
header h1 {
  margin:0; font-size: 28px; letter-spacing: 0.5px; color: var(--accent-1);
  text-shadow: 1px 1px #000;
}
header p {
  margin: 6px 0 0 0; color: var(--ink-1);
}

main { padding: 16px; display: grid; grid-template-columns: 340px 1fr; gap: 16px; }
@media (max-width: 1100px) { main { grid-template-columns: 1fr; } }

.panel {
  background: var(--panel);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 14px;
  box-shadow: var(--shadow);
}

.panel h2 {
  margin:0 0 10px 0; font-size: 18px; color: var(--accent-2);
}

.row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.badge {
  display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius: 999px;
  font-size: 12px; background: var(--panel-strong); color: var(--ink-1);
}
.badge.ok { color: var(--ok); }
.badge.fail { color: var(--fail); }

button.sys {
  background: var(--accent-3); color:#fff; border:none; border-radius: 10px; padding: 10px 14px; font-weight: 700;
  box-shadow: var(--shadow); cursor: pointer; transition: transform .15s, filter .15s;
}
button.sys:hover { transform: translateY(-1px); filter: brightness(1.05); }
button.sys.alt { background: var(--accent-2); }
button.sys.warn { background: var(--accent-4); color:#111; }
button.sys.gray { background: #334; color: var(--ink-1); }

section.stack { display:grid; gap: 12px; }

.card {
  background: var(--panel);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 12px;
}
.card h3 { margin:0 0 8px 0; font-size: 16px; color: var(--accent-5); }

.kv { display:grid; grid-template-columns: 160px 1fr; gap: 8px; }
.kv div { padding: 6px 8px; border-radius: 8px; background: rgba(255,255,255,0.04); }
code.inline { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 6px; }

#log {
  background: #0b111b; border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; height: 320px;
  overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px; line-height: 1.35;
}
.log-line { margin: 2px 0; }
.log-line .t { color: var(--mute); }
.log-line .ok { color: var(--ok); }
.log-line .err { color: var(--fail); }

#ledger {
  background: #0b111b; border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; height: 280px;
  overflow: auto; font-family: ui-monospace, monospace; font-size: 12px;
}

footer {
  padding: 14px; margin-top: 10px;
  color: var(--ink-1); text-align: center;
}
footer small { color: var(--mute); }
</style>
</head>
<body>
<header>
  <h1>Infinity‑OS System Orchestrator</h1>
  <p>Operating carts as engines. Queue, run, log, and ledger — without noisy filenames.</p>
</header>

<main>
  <!-- ================== LEFT: OS Controls & Health ================== -->
  <aside class="panel">
    <h2>System</h2>
    <div class="row" id="healthRow">
      <span class="badge" id="backendBadge">Backend: checking…</span>
      <span class="badge" id="queueBadge">Queue: idle</span>
      <span class="badge" id="runBadge">Run mode: stopped</span>
    </div>

    <div style="height:8px"></div>

    <div class="row">
      <button class="sys" id="bootBtn">Boot OS</button>
      <button class="sys alt" id="resumeBtn">Resume</button>
      <button class="sys warn" id="pauseBtn">Pause</button>
      <button class="sys gray" id="stopBtn">Stop</button>
      <button class="sys gray" id="refreshLedgerBtn">Refresh ledger</button>
    </div>

    <div style="height:14px"></div>

    <div class="card">
      <h3>Routing</h3>
      <div class="kv">
        <div>Backend</div><div><code class="inline" id="backendUrlCode"></code></div>
        <div>Concurrency</div><div><code class="inline" id="concCode"></code></div>
        <div>Retry policy</div><div><code class="inline" id="retryCode"></code></div>
      </div>
    </div>

    <div style="height:14px"></div>

    <div class="card">
      <h3>Run plan</h3>
      <div id="planView"></div>
    </div>
  </aside>

  <!-- ================== RIGHT: Logs & Ledger ================== -->
  <section class="stack">
    <div class="panel">
      <h2>Live logs</h2>
      <div id="log"></div>
    </div>

    <div class="panel">
      <h2>Provenance ledger</h2>
      <div id="ledger"></div>
    </div>
  </section>
</main>

<footer>
  <small>Infinity‑OS • Engines mapped to human domains • Repo-first provenance • Termux localhost</small>
</footer>

<script>
/* ===== Infinity‑OS System Brain ===== */

// Backend lives on the device in Termux
const BACKEND = "http://127.0.0.1:5000";
const HEALTH_ENDPOINT = BACKEND + "/";
const RUN_ENDPOINT    = BACKEND + "/run?cart=";
const LOGS_ENDPOINT   = BACKEND + "/logs";

// Concurrency / retries
const CONCURRENCY_LIMIT = 3;
const MAX_RETRIES = 2;
const RETRY_DELAY_MS = 1200;
const BACKOFF_FACTOR = 1.7;

// Health, run state
let runMode = "stopped"; // "running" | "paused" | "stopped"
let activeWorkers = 0;
let queue = [];
let inflight = new Map();

// UI refs
const backendBadge = document.getElementById("backendBadge");
const queueBadge   = document.getElementById("queueBadge");
const runBadge     = document.getElementById("runBadge");
const backendUrlCode = document.getElementById("backendUrlCode");
const concCode       = document.getElementById("concCode");
const retryCode      = document.getElementById("retryCode");
const logEl       = document.getElementById("log");
const ledgerEl    = document.getElementById("ledger");
const planView    = document.getElementById("planView");

document.getElementById("bootBtn").onclick = () => startRun();
document.getElementById("resumeBtn").onclick = () => { runMode = "running"; updateBadges(); pump(); };
document.getElementById("pauseBtn").onclick = () => { runMode = "paused"; updateBadges(); };
document.getElementById("stopBtn").onclick = () => stopRun();
document.getElementById("refreshLedgerBtn").onclick = () => refreshLedger();

/* ===== Domain map: human labels → file IDs =====
   We do not show filenames in UI; we orchestrate them as engines.
   Additions welcome — mapped from your repo lists.
*/
const ENGINES = [
  // Foundation & engineer lanes
  { label: "Engineer",           id: "cart002_engineering.py" },
  { label: "Computers",          id: "cart003_computers.py" },
  { label: "Nuances",            id: "cart004_nuances.py" },
  { label: "Code",               id: "cart005_code.py" },
  { label: "Python",             id: "cart006_python.py" },
  { label: "Tokens",             id: "cart007_tokens.py" },
  { label: "Government",         id: "cart008_government.py" },
  { label: "Power",              id: "cart009_power.py" },
  { label: "Components",         id: "cart010_components.py" },
  { label: "Speakeasy",          id: "cart011_speakeasy.py" },

  // Chemistry / materials / engines
  { label: "Solutes",            id: "cart012_solutes.py" },
  { label: "Mercury Al Growth",  id: "cart013_mercury_aluminum_growth.py" },
  { label: "Mercury Vapor Power",id: "cart014_mercury_vapor_power.py" },
  { label: "Hydrogen Compression",id:"cart015_compression_hydrogen_engine.py" },
  { label: "Hot/Cold TEG",       id: "cart016_hot_cold_TEG.py" },
  { label: "Spiderweb Engine",   id: "cart017_spiderweb_engine.py" },
  { label: "Zip Hashing",        id: "cart018_zip_hashing.py" },
  { label: "Token Generation",   id: "cart019_token_generation.py" },
  { label: "Unzip Install",      id: "cart020_unzip_install_strategy.py" },
  { label: "Token Tiers",        id: "cart021_token_tiers.py" },
  { label: "Bank‑grade Tokens",  id: "cart022_bank_grade_tokens.py" },
  { label: "Idea Merger",        id: "cart023_idea_merger.py" },
  { label: "Quantum Transport",  id: "cart024_quantum_transport.py" },
  { label: "AI Watcher Login",   id: "cart025_ai_watcher_login.py" },
  { label: "Aluminum Oxide",     id: "cart026_aluminum_oxide_devices.py" },
  { label: "Robotics",           id: "cart027_robotics.py" },
  { label: "Machines",           id: "cart028_machines.py" },
  { label: "Crystal Truths",     id: "cart029_crystal_truths.py" },
  { label: "Superchem Fireproof",id: "cart030_superchemistry_fireproof.py" },
  { label: "Exoskeleton",        id: "cart031_exoskeleton.py" },
  { label: "Ecosystem",          id: "cart032_ecosystem.py" },
  { label: "Nature",             id: "cart033_nature.py" },
  { label: "Drones",             id: "cart034_drones.py" },
  { label: "Signal Trace",       id: "cart035_signal_trace.py" },
  { label: "RF Generation",      id: "cart036_rf_generation.py" },
  { label: "Mice Brainmapping",  id: "cart037_mice_brainmapping.py" },
  { label: "Genetics",           id: "cart038_genetics.py" },
  { label: "DNA Engine",         id: "cart039_dna_engine.py" },
  { label: "Gas Shell Code",     id: "cart040_gas_shell_code.py" },
  { label: "Hydrogen Expansion", id: "cart041_hydrogen_expansion.py" },

  // Site / wallet / ledger / UI engines (from your folder listings)
  { label: "Feed Generator",     id: "cart804_feed_generator.py" },
  { label: "Wallet Engine",      id: "cart805_wallet_engine.py" },
  { label: "Writer Engine",      id: "cart803_writer_engine.py" },
  { label: "Button Routing",     id: "cart802_button_routing_engine.py" },
  { label: "Terminal Engine",    id: "cart801_terminal_engine.py" },
  { label: "World Ledger",       id: "cart823_world_ledger.py" },
  { label: "Local‑first Sync",   id: "cart824_local_first_sync.py" },
  { label: "IPFS Client",        id: "cart821_ipfs_client.py" },
  { label: "IPFS Publisher",     id: "cart822_ipfs_publisher.py" },
  { label: "User Capsule",       id: "cart825_user_capsule.py" },
  { label: "Gateway Selector",   id: "cart826_gateway_selector.py" },

  // Accounts / crypto / user management (from list)
  { label: "Capsule Template",   id: "cart901_capsule_template.py" },
  { label: "Crypto",             id: "cart902_pewpi_crypto.py" },
  { label: "Account Create",     id: "cart903_account_create.py" },
  { label: "Login",              id: "cart904_login.py" },
  { label: "Capsule Backup",     id: "cart905_capsule_backup.py" },
  { label: "User Manager",       id: "cart906_user_manager.py" },

  // Research / writers (subset mapped for now)
  { label: "Research Writer",    id: "cart_research_writer.py" },
  { label: "Research Writer v2", id: "cart_research_writer_v2.py" },
  { label: "Research 100 Gen",   id: "cart_research100_generator.py" },
  { label: "Graph Narrative",    id: "cart328_graph_narrative_writer.py" },
  { label: "Full Bundle Writer", id: "cart330_full_research_bundle_writer.py" },

  // Infra / index builders
  { label: "Website Folder Builder", id: "cart701_website_folder_builder.py" },
  { label: "Index HTML Builder",     id: "cart702_index_html_builder.py" },
  { label: "Category Page Builder",  id: "cart703_category_page_builder.py" },
  { label: "Research Preview Builder", id: "cart704_research_preview_builder.py" },
  { label: "Color Logic UI",         id: "cart706_color_logic_ui_builder.py" },
  { label: "Crossover Visualizer",   id: "cart707_crossover_visualizer.py" },
  { label: "Zip Explorer",           id: "cart708_zip_explorer.py" },
  { label: "Navigation System",      id: "cart709_navigation_system.py" },
  { label: "Pages Deployer",         id: "cart710_github_pages_deployer.py" },

  // Github ops / push / metadata
  { label: "GitHub Init",            id: "cart421_github_initializer.py" },
  { label: "GitHub Credential Loader", id: "cart422_github_credential_loader.py" },
  { label: "GitHub Push",            id: "cart423_github_push.py" },
  { label: "Token Metadata Builder", id: "cart424_token_metadata_builder.py" },
  { label: "Token Signature Engine", id: "cart425_token_signature_engine.py" },
  { label: "Token Lineage Recorder", id: "cart426_token_lineage_recorder.py" },
  { label: "Token Version History",  id: "cart427_token_version_history.py" },
  { label: "Token Register",         id: "cart428_token_register.py" },
  { label: "Token Vault",            id: "cart429_token_vault.py" },
  { label: "Token Exporter",         id: "cart430_token_exporter.py" },

  // Autonomy & schedulers
  { label: "Autonomous Kernel",      id: "cart501_autonomous_kernel.py" },
  { label: "Event Watcher",          id: "cart502_research_event_watcher.py" },
  { label: "Rebuild Trigger",        id: "cart503_rebuild_trigger.py" },
  { label: "Watchdog",               id: "cart504_watchdog.py" },
  { label: "Autonomous Scheduler",   id: "cart505_autonomous_scheduler.py" },
  { label: "Universal Calculator",   id: "cart506_universal_calculator_engine.py" },
  { label: "Autonomous Rebuilder",   id: "cart507_autonomous_rebuilder.py" },
  { label: "Hazard Recovery",        id: "cart508_hazard_recovery.py" },
  { label: "Persistent Calc Loop",   id: "cart509_persistent_calc_loop.py" },
  { label: "Full Autonomy Daemon",   id: "cart510_full_autonomy_daemon.py" }
];

// Phases (ordered): orchestrate engines intelligently
const PHASES = [
  { name: "Boot",     list: ["Engineer","Computers","Code","Python","Tokens"] },
  { name: "Materials",list: ["Solutes","Hydrogen Compression","Hot/Cold TEG","Spiderweb Engine"] },
  { name: "Systems",  list: ["Robotics","Machines","Signal Trace","RF Generation","Drones"] },
  { name: "Bio",      list: ["Genetics","DNA Engine","Mice Brainmapping","Nature","Ecosystem"] },
  { name: "Ledger",   list: ["World Ledger","Token Register","Token Vault","Wallet Engine","Crypto"] },
  { name: "Site",     list: ["Website Folder Builder","Index HTML Builder","Navigation System","Pages Deployer"] },
  { name: "Autonomy", list: ["Autonomous Kernel","Watchdog","Autonomous Scheduler","Full Autonomy Daemon"] },
  { name: "Research", list: ["Research Writer","Research Writer v2","Research 100 Gen","Graph Narrative","Full Bundle Writer"] }
];

// Make a map label -> id
const ID_MAP = new Map(ENGINES.map(e => [e.label, e.id]));

// Helpers
function now() {
  const d = new Date();
  return d.toISOString();
}
function log(line, cls="") {
  const div = document.createElement("div");
  div.className = "log-line";
  div.innerHTML = `<span class="t">[${now()}]</span> <span class="${cls}">${line}</span>`;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}
function setBadge(el, text, cls="") {
  el.textContent = text;
  el.className = "badge " + cls;
}
function updateBadges() {
  setBadge(queueBadge, `Queue: ${queue.length} queued, ${activeWorkers} active`);
  setBadge(runBadge, `Run mode: ${runMode}`, runMode === "running" ? "ok" : (runMode === "paused" ? "" : "fail"));
}

// Health probe
async function checkBackend() {
  backendUrlCode.textContent = BACKEND;
  concCode.textContent = `${CONCURRENCY_LIMIT} workers`;
  retryCode.textContent = `${MAX_RETRIES} retries, ${RETRY_DELAY_MS}ms, x${BACKOFF_FACTOR}`;

  setBadge(backendBadge, "Backend: probing…");
  try {
    const res = await fetch(HEALTH_ENDPOINT, { method:"GET" });
    setBadge(backendBadge, res.ok ? "Backend: online" : "Backend: not responding", res.ok ? "ok" : "fail");
    log(res.ok ? "✅ Backend online" : "❌ Backend not responding", res.ok ? "ok" : "err");
  } catch (e) {
    setBadge(backendBadge, "Backend: unreachable", "fail");
    log(`❌ Backend unreachable: ${e}`, "err");
  }
}

// Build plan view
function buildPlanView() {
  planView.innerHTML = "";
  PHASES.forEach(phase => {
    const box = document.createElement("div");
    box.className = "card";
    const title = document.createElement("h3");
    title.textContent = `Phase • ${phase.name}`;
    box.appendChild(title);
    const list = document.createElement("ul");
    list.style.listStyle = "none";
    list.style.padding = "0";
    phase.list.forEach(lbl => {
      const li = document.createElement("li");
      li.style.padding = "4px 0";
      li.innerHTML = `<span class="badge">${lbl}</span>`;
      list.appendChild(li);
    });
    box.appendChild(list);
    planView.appendChild(box);
  });
}

// Queue builder
function buildQueueFromPhases() {
  queue = []; // reset
  PHASES.forEach(phase => {
    phase.list.forEach(lbl => {
      const id = ID_MAP.get(lbl);
      if (!id) {
        log(`⚠️ No file id found for label "${lbl}"`, "err");
      } else {
        queue.push({ label: lbl, id, phase: phase.name, retries: 0 });
      }
    });
  });
  updateBadges();
}

// Runner
async function runEngine(item) {
  const param = item.id.replace(".py",""); // backend may accept filename sans .py
  const url = RUN_ENDPOINT + encodeURIComponent(param);
  inflight.set(param, true);
  activeWorkers++;
  updateBadges();

  log(`▶ ${item.phase} • ${item.label} • ${param}`, "t");
  let attempt = item.retries + 1;
  try {
    const res = await fetch(url, { method:"GET" });
    const data = await res.json().catch(() => ({}));
    if (res.ok && data && (data.status === "success" || data.exit_code === 0)) {
      log(`✅ ${item.label} ok • ${data.duration_ms || "n/a"}ms`, "ok");
      if (data.stdout_preview) log(`⟶ ${item.label} • ${data.stdout_preview}`, "ok");
    } else {
      const msg = (data && (data.stderr_preview || data.error)) || `HTTP ${res.status}`;
      throw new Error(msg);
    }
  } catch (e) {
    log(`❌ ${item.label} failed • ${String(e).slice(0,300)}`, "err");
    if (item.retries < MAX_RETRIES && runMode === "running") {
      item.retries++;
      const delay = Math.floor(RETRY_DELAY_MS * Math.pow(BACKOFF_FACTOR, item.retries - 1));
      log(`↻ retrying ${item.label} in ${delay}ms (attempt ${attempt}/${MAX_RETRIES + 1})`, "t");
      await sleep(delay);
      // re-enqueue at front to prioritize retry
      queue.unshift(item);
    }
  } finally {
    inflight.delete(param);
    activeWorkers--;
    updateBadges();
  }
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function pump() {
  if (runMode !== "running") return;
  // Start workers up to limit
  while (runMode === "running" && activeWorkers < CONCURRENCY_LIMIT && queue.length > 0) {
    const item = queue.shift();
    runEngine(item);
    updateBadges();
    // slight yield to avoid tight loop
    await sleep(60);
  }
  // Keep pumping
  if (runMode === "running") {
    setTimeout(pump, 250);
  }
}

function startRun() {
  runMode = "running";
  updateBadges();
  buildQueueFromPhases();
  pump();
}

function stopRun() {
  runMode = "stopped";
  updateBadges();
  queue = [];
  log("■ System stopped. Queue cleared.", "t");
}

// Ledger refresh
async function refreshLedger() {
  log("⎈ Refreshing ledger…", "t");
  try {
    const res = await fetch(LOGS_ENDPOINT, { method:"GET" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    ledgerEl.textContent = text;
    log("✅ Ledger refreshed", "ok");
  } catch (e) {
    log(`❌ Ledger refresh failed • ${e}`, "err");
  }
}

// Boot
(async
// Boot
(async function boot() {
  buildPlanView();
  await checkBackend();
  refreshLedger();
  updateBadges();
})();
</script>
</body>
</html>
